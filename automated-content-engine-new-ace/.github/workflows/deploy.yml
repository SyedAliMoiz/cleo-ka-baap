name: Build and Deploy to ECR/EC2

on:
  push:
    branches: [main]
  workflow_dispatch:

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v2

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v1

      - name: Build, tag, and push backend image to ECR
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: ace/backend
          IMAGE_TAG: ${{ github.sha }}
        run: |
          # Build backend image
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG -t $ECR_REGISTRY/$ECR_REPOSITORY:latest -f docker/backend/Dockerfile ./backend

          # Push both tags to ECR
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest

          echo "::set-output name=backend_image::$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"

      - name: Build, tag, and push frontend image to ECR
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: ace/frontend
          IMAGE_TAG: ${{ github.sha }}
        run: |
          # Build frontend image
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG -t $ECR_REGISTRY/$ECR_REPOSITORY:latest -f docker/frontend/Dockerfile ./frontend

          # Push both tags to ECR
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest

          echo "::set-output name=frontend_image::$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"

      - name: Build, tag, and push nginx image to ECR
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: ace/nginx
          IMAGE_TAG: ${{ github.sha }}
        run: |
          # Copy nginx config to a temp directory
          mkdir -p ./nginx-build
          cp ./docker/nginx/nginx.conf ./nginx-build/

          # Create minimal Dockerfile for nginx
          echo "FROM nginx:alpine" > ./nginx-build/Dockerfile
          echo "COPY nginx.conf /etc/nginx/nginx.conf" >> ./nginx-build/Dockerfile

          # Build nginx image
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG -t $ECR_REGISTRY/$ECR_REPOSITORY:latest ./nginx-build

          # Push both tags to ECR
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest

          echo "::set-output name=nginx_image::$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"

      - name: Create deployment configuration
        run: |
          # Create a docker-compose file for deployment
          cat > docker-compose.deploy.yml << EOF
          version: '3.8'

          services:
            nginx:
              image: ${{ steps.login-ecr.outputs.registry }}/ace/nginx:latest
              ports:
                - "80:80"
                - "443:443"
              volumes:
                - /etc/letsencrypt:/etc/letsencrypt:ro
                - /var/lib/letsencrypt:/var/lib/letsencrypt:ro
                - certbot-webroot:/var/www/certbot:ro
              depends_on:
                - frontend
                - backend
              restart: always

            frontend:
              image: ${{ steps.login-ecr.outputs.registry }}/ace/frontend:latest
              environment:
                - NODE_ENV=production
                - NEXT_PUBLIC_API_URL=/api
              depends_on:
                - backend
              restart: always

            backend:
              image: ${{ steps.login-ecr.outputs.registry }}/ace/backend:latest
              environment:
                - NODE_ENV=production
                - MONGODB_URI=mongodb://mongo:27017/ace
                - ANTHROPIC_API_KEY=${{ secrets.ANTHROPIC_API_KEY }}
                - GOOGLE_NEWS_API_KEY=${{ secrets.GOOGLE_NEWS_API_KEY }}
                - OPENAI_API_KEY=${{ secrets.OPENAI_API_KEY }}
                - PERPLEXITY_API_KEY=${{ secrets.PERPLEXITY_API_KEY }}
                - ALLOWED_ORIGINS=http://localhost:3000,https://ace.vyralab.com
              depends_on:
                - mongo
              restart: always

            mongo:
              image: mongo:latest
              volumes:
                - /data/db:/data/db
              environment:
                - MONGO_INITDB_DATABASE=ace
              restart: always

            certbot:
              image: certbot/certbot
              volumes:
                - /etc/letsencrypt:/etc/letsencrypt
                - /var/lib/letsencrypt:/var/lib/letsencrypt
                - certbot-webroot:/var/www/certbot
              entrypoint: "/bin/sh -c 'trap exit TERM; while :; do certbot renew; sleep 12h & wait \$\${!}; done;'"
              restart: always

          volumes:
            certbot-webroot:
            mongodb_data:
              driver: local
          EOF

      - name: Set up SSH
        uses: webfactory/ssh-agent@v0.5.4
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: Add SSH known hosts
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan -H ${{ secrets.EC2_HOST }} >> ~/.ssh/known_hosts

      - name: Copy deployment files to EC2
        run: |
          # Create deploy script
          cat > deploy.sh << 'EOF'
          #!/bin/bash
          set -e

          # Login to ECR
          aws ecr get-login-password --region "$AWS_REGION" | docker login --username AWS --password-stdin "$ECR_REGISTRY"

          # Stop any running containers
          docker-compose -f docker-compose.deploy.yml down || echo "No containers to stop"

          # CLEANUP: remove old, unused images safely
          echo "Cleaning up unused Docker images and cache..."
          docker system prune -af --volumes || true

          # Pull latest images
          docker-compose -f docker-compose.deploy.yml pull

          # Start containers
          docker-compose -f docker-compose.deploy.yml up -d

          # Print status
          docker-compose -f docker-compose.deploy.yml ps

          echo "Deployment completed successfully"
          EOF

          chmod +x deploy.sh

          # Copy files to EC2
          scp docker-compose.deploy.yml ec2-user@${{ secrets.EC2_HOST }}:~/docker-compose.deploy.yml
          scp deploy.sh ec2-user@${{ secrets.EC2_HOST }}:~/deploy.sh

      - name: Deploy to EC2
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          AWS_REGION: ${{ secrets.AWS_REGION }}
        run: |
          # Run deployment script on EC2
          ssh ec2-user@${{ secrets.EC2_HOST }} "
            export ECR_REGISTRY=$ECR_REGISTRY
            export AWS_REGION=$AWS_REGION
            ./deploy.sh
          "

          echo "Deployment successful!"
